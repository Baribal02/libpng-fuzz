#!/bin/bash -u
# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
################################################################################

# Global variable that can be overwritten by any check.
BAD_BUILD_CHECK_FAILED=0

# Verify that the given fuzz target has proper coverage instrumentation.
function check_instrumentation {
  local FUZZER=$1
  local LOG_PATH_FOR_BROKEN_TARGET=$2
  local CHECK_FAILED=0
  local FUZZER_OUTPUT="/tmp/$(basename $FUZZER).output"

  if [[ "$FUZZING_ENGINE" = libfuzzer ]]; then
    $FUZZER -runs=4 &>$FUZZER_OUTPUT
    CHECK_FAILED=$(cat $FUZZER_OUTPUT | egrep "ERROR: no interesting inputs were found. Is the code instrumented" -c)
    if (( $CHECK_FAILED > 0 )); then
      echo "BAD BUILD: the target does not seem to have coverage instrumentation." >> $LOG_PATH_FOR_BROKEN_TARGET
      BAD_BUILD_CHECK_FAILED=1

      # Bail out as the further check does not make any sense, there are 0 PCs.
      return 1
    fi

    local NUMBER_OF_EDGES=$(cat $FUZZER_OUTPUT | grep -Po "INFO: Loaded [[:digit:]]+ module.*\(.*counters\):[[:space:]]+\K[[:digit:]]+")

    # The "example" target has 93 when built with ASan and 67 with UBSan. Real
    # targets have greater values (arduinojson: 413, libteken: 519, zlib: 586).
    local THRESHOLD_FOR_NUMBER_OF_EDGES=90
    if [[ $SANITIZER = undefined ]]; then
      THRESHOLD_FOR_NUMBER_OF_EDGES=65
    fi

    if (( $NUMBER_OF_EDGES < $THRESHOLD_FOR_NUMBER_OF_EDGES )); then
      echo "BAD BUILD: the target seems to have only partial coverage instrumentation." >> $LOG_PATH_FOR_BROKEN_TARGET
      BAD_BUILD_CHECK_FAILED=1
    fi
  fi
}

# Verify that the given fuzz target has been built properly and works.
function check_startup_crash {
  local FUZZER=$1
  local LOG_PATH_FOR_BROKEN_TARGET=$2
  local CHECK_PASSED=0

  if [[ "$FUZZING_ENGINE" = libfuzzer ]]; then
    CHECK_PASSED=$($FUZZER -runs=4 2>&1 | egrep "Done 4 runs" -c)
  else
    # TODO: add checks for another fuzzing engines if possible.
    CHECK_PASSED=1
  fi

  if [ "$CHECK_PASSED" -eq "0" ]; then
    echo "BAD BUILD: the fuzzer seems to have either startup crash or exit." >> $LOG_PATH_FOR_BROKEN_TARGET
    BAD_BUILD_CHECK_FAILED=1
  fi
}

# Mixed sanitizers check for ASan build.
function check_asan_build {
  local FUZZER=$1
  local LOG_PATH_FOR_BROKEN_TARGET=$2
  local ASAN_CALLS=$3
  local MSAN_CALLS=$4
  local UBSAN_CALLS=$5

  # Perform all the checks for more detailed error message.
  if (( $ASAN_CALLS < 1000 )); then
    echo "BAD BUILD: $FUZZER does not seem to be compiled with ASan." >> $LOG_PATH_FOR_BROKEN_TARGET
    BAD_BUILD_CHECK_FAILED=1
  fi

  if (( $MSAN_CALLS > 0 )); then
    echo "BAD BUILD: ASan build of $FUZZER seems to be compiled with MSan." >> $LOG_PATH_FOR_BROKEN_TARGET
    BAD_BUILD_CHECK_FAILED=1
  fi

  if (( $UBSAN_CALLS > 250 )); then
    echo "BAD BUILD: ASan build of $FUZZER seems to be compiled with UBSan." >> $LOG_PATH_FOR_BROKEN_TARGET
    BAD_BUILD_CHECK_FAILED=1
  fi
}

# Mixed sanitizers check for MSan build.
function check_msan_build {
  local FUZZER=$1
  local LOG_PATH_FOR_BROKEN_TARGET=$2
  local ASAN_CALLS=$3
  local MSAN_CALLS=$4
  local UBSAN_CALLS=$5

  # Perform all the checks for more detailed error message.
  if (( $ASAN_CALLS > 0 )); then
    echo "BAD BUILD: MSan build of $FUZZER seems to be compiled with ASan." >> $LOG_PATH_FOR_BROKEN_TARGET
    BAD_BUILD_CHECK_FAILED=1
  fi

  if (( $MSAN_CALLS < 1000 )); then
    echo "BAD BUILD: $FUZZER does not seem to be compiled with UBSan." >> $LOG_PATH_FOR_BROKEN_TARGET
    BAD_BUILD_CHECK_FAILED=1
  fi

  if (( $UBSAN_CALLS > 250 )); then
    echo "BAD BUILD: MSan build of $FUZZER seems to be compiled with UBSan." >> $LOG_PATH_FOR_BROKEN_TARGET
    BAD_BUILD_CHECK_FAILED=1
  fi
}

# Mixed sanitizers check for UBSan build.
function check_ubsan_build {
  local FUZZER=$1
  local LOG_PATH_FOR_BROKEN_TARGET=$2
  local ASAN_CALLS=$3
  local MSAN_CALLS=$4
  local UBSAN_CALLS=$5

  if [[ "$FUZZING_ENGINE" != libfuzzer ]]; then
    # Ignore UBSan checks for fuzzing engines other than libFuzzer because:
    # A) we (probably) are not going to use those with UBSan
    # B) such builds show indistinguishable number of calls to UBSan
    return 0
  fi

  # Perform all the checks for more detailed error message.
  if (( $ASAN_CALLS > 0 )); then
    echo "BAD BUILD: UBSan build of $FUZZER seems to be compiled with ASan." >> $LOG_PATH_FOR_BROKEN_TARGET
    BAD_BUILD_CHECK_FAILED=1
  fi

  if (( $MSAN_CALLS > 0 )); then
    echo "BAD BUILD: UBSan build of $FUZZER seems to be compiled with MSan." >> $LOG_PATH_FOR_BROKEN_TARGET
    BAD_BUILD_CHECK_FAILED=1
  fi

  if (( $UBSAN_CALLS < 250 )); then
    echo "BAD BUILD: $FUZZER does not seem to be compiled with UBSan." >> $LOG_PATH_FOR_BROKEN_TARGET
    BAD_BUILD_CHECK_FAILED=1
  fi
}

# Verify that the given fuzz target is compiled with correct sanitizer.
function check_mixed_sanitizers {
  local FUZZER=$1
  local LOG_PATH_FOR_BROKEN_TARGET=$2

  local ASAN_CALLS=$(objdump -dC $FUZZER | egrep "callq\s+[0-9a-f]+\s+<__asan" -c)
  local MSAN_CALLS=$(objdump -dC $FUZZER | egrep "callq\s+[0-9a-f]+\s+<__msan" -c)
  local UBSAN_CALLS=$(objdump -dC $FUZZER | egrep "callq\s+[0-9a-f]+\s+<__ubsan" -c)

  if [[ "$SANITIZER" = address ]]; then
    check_asan_build $FUZZER $LOG_PATH_FOR_BROKEN_TARGET $ASAN_CALLS $MSAN_CALLS $UBSAN_CALLS
  elif [[ "$SANITIZER" = memory ]]; then
    check_msan_build $FUZZER $LOG_PATH_FOR_BROKEN_TARGET $ASAN_CALLS $MSAN_CALLS $UBSAN_CALLS
  elif [[ "$SANITIZER" = undefined ]]; then
    check_ubsan_build $FUZZER $LOG_PATH_FOR_BROKEN_TARGET $ASAN_CALLS $MSAN_CALLS $UBSAN_CALLS
  fi
}


function main {
  local FUZZER=$1
  local LOG_PATH_FOR_BROKEN_TARGET=$2

  echo "INFO: performing bad build checks for $FUZZER"

  check_instrumentation $FUZZER $LOG_PATH_FOR_BROKEN_TARGET
  check_mixed_sanitizers $FUZZER $LOG_PATH_FOR_BROKEN_TARGET
  check_startup_crash $FUZZER $LOG_PATH_FOR_BROKEN_TARGET
}


if [ $# -ne 3 ]; then
    echo "Usage: $0 <fuzz_target_binary> <valid_targets_dir> <broken_targets_dir>"
    exit 1
fi

# Fuzz target path.
FUZZER=$1

# Directory where names of valid fuzz targets will be written to. It's expected
# to have an empty file for every valid fuzz target.
VALID_TARGETS_DIR=$2

# Directory where names of broken fuzz targets will be written to. It's expected
# ti have a file with error message for every broken fuzz target.
BROKEN_TARGETS_DIR=$3

TARGET_NAME="$(basename $FUZZER)"
LOG_PATH_FOR_BROKEN_TARGET="${BROKEN_TARGETS_DIR}/${TARGET_NAME}"

# In case of an error, main function will write error(s) to the given log path.
main $FUZZER $LOG_PATH_FOR_BROKEN_TARGET

if [ "$BAD_BUILD_CHECK_FAILED" -eq "0" ]; then
  echo "INFO: $FUZZER has passed bad build checks."

  # Record valid fuzz target name into the valid targets dir.
  touch ${VALID_TARGETS_DIR}/${TARGET_NAME}
else
  echo "INFO: $FUZZER has failed bad build checks."
fi
